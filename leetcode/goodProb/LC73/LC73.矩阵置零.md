## LC73.矩阵置零

[73. 矩阵置零 - 力扣（LeetCode）](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=programming-skills)

> 给定一个 $n \times m$ 的矩阵，如果一个元素为 $0$，请将它所在的行和列的所有元素都设为 $0$。请使用**原地**算法。

好感度：100

#### 原地？

这道题是我第一次接触**原地**这个概念。原地，就是在只允许开 $O(1)$ 的额外空间的条件下，对数组进行一定的修改。

不原地的做法是好想的，难点在于如何变成原地。

#### 不原地的做法

显然我们可以拿两个数组记录每一行、每一列是否出现过 $0$，然后再根据这两个数组来修改矩阵。

时间复杂度 $O(nm)$，空间复杂度 $O(n+m)$。

#### 原地做法

我没想出来，看了题解。

本题的做法是**拿第一行和第一列来充当我们想要的两个数组**。

显然会有个问题：这一行一列怎么办呢？我们可以拿两个临时变量来存这一行一列是否要归 $0$ ！

这里涉及到一个很妙的点：第一行上每个数字表示该列是否要置 $0$，而如果最终第一行不需要置 $0$，那么我们**无需进行任何修改**！第一列同理——而第一个数字比较神奇，它又在第一行又在第一列，这里我们可以认为它只管第一行（第一列也是可以的），然后只需要拿一个临时变量来存储就可以了。

#### 梳理实现思路

<img src="..\img\image-20250317202515123.png" alt="image-20250317202515123" style="zoom:80%;" />

1. 根据第一行的值更新临时变量 $x$
2. 从第一列开始，根据每一列的值更新第一行的值
3. 从**第二行**开始，根据每一行的值更新第一列的值
4. 根据第一列的值进行置零
5. 根据第一行的值进行置零
6. 根据 $x$ 对第一行进行置零


#### 总结

我认为本题的关键点在于**压缩以保护数据**。在不原地算法中，我们将整个矩阵的置零信息压缩成两个数组，究其原因也是为了保护原矩阵的信息；而原地算法要求我们将这两个数组放入原矩阵中，那么为了保护原来的两个数组，我们将它们先一步压缩为两个临时变量（尽管最后只用了一个）

在写实现思路的时候，能很明显地感受到为了保护数据而设计的覆盖顺序。这题我很喜欢！

#### Bonus

其实实现步骤中第 $3$ 和第 $4$ 是可以合并的。
